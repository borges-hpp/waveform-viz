<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Waveform Terrain — WebGL</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
  canvas { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:2em">WebGL not supported</p>'; throw ''; }

const ASPECT = 16 / 9;
const RENDER_W = 1920, RENDER_H = Math.round(RENDER_W / ASPECT);

function resize() {
  canvas.width = RENDER_W; canvas.height = RENDER_H;
  gl.viewport(0, 0, RENDER_W, RENDER_H);
  const vw = window.innerWidth, vh = window.innerHeight;
  const scale = Math.max(vw / RENDER_W, vh / RENDER_H);
  canvas.style.width = (RENDER_W * scale) + 'px';
  canvas.style.height = (RENDER_H * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();

// Simple shaders
const vsrc = `
attribute vec2 aPos;
attribute float aAlpha;
varying float vAlpha;
void main() {
  // Convert pixel coords to clip space
  vec2 clip = (aPos / vec2(${RENDER_W}.0, ${RENDER_H}.0)) * 2.0 - 1.0;
  clip.y = -clip.y; // flip Y (pixel 0 = top)
  gl_Position = vec4(clip, 0.0, 1.0);
  vAlpha = aAlpha;
}`;

const fsrc = `
precision mediump float;
varying float vAlpha;
uniform vec4 uColor;
void main() {
  gl_FragColor = vec4(uColor.rgb, uColor.a * vAlpha);
}`;

function makeShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, makeShader(vsrc, gl.VERTEX_SHADER));
gl.attachShader(prog, makeShader(fsrc, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, 'aPos');
const aAlpha = gl.getAttribLocation(prog, 'aAlpha');
const uColor = gl.getUniformLocation(prog, 'uColor');

const posBuf = gl.createBuffer();
const alphaBuf = gl.createBuffer();

gl.enableVertexAttribArray(aPos);
gl.enableVertexAttribArray(aAlpha);

gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

// Noise (same as canvas version)
const perm = new Uint8Array(512);
const grad = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
(function() {
  const p = new Uint8Array(256);
  for (let i = 0; i < 256; i++) p[i] = i;
  for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
  for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
})();

function noise2d(x, y) {
  const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
  const xf = x - Math.floor(x), yf = y - Math.floor(y);
  const u = xf * xf * (3 - 2 * xf), v = yf * yf * (3 - 2 * yf);
  const aa = perm[perm[X] + Y], ab = perm[perm[X] + Y + 1];
  const ba = perm[perm[X + 1] + Y], bb = perm[perm[X + 1] + Y + 1];
  const dot = (g, dx, dy) => grad[g & 7][0] * dx + grad[g & 7][1] * dy;
  return (dot(aa,xf,yf)*(1-u)+dot(ba,xf-1,yf)*u)*(1-v) + (dot(ab,xf,yf-1)*(1-u)+dot(bb,xf-1,yf-1)*u)*v;
}

function fbm(x, y, oct) {
  let val = 0, amp = 1, freq = 1, max = 0;
  for (let i = 0; i < oct; i++) { val += noise2d(x*freq, y*freq)*amp; max += amp; amp *= 0.5; freq *= 2; }
  return val / max;
}

const W = RENDER_W, H = RENDER_H;
const NUM_LINES = 180;
const POINTS = 600;

let time = 0;

function computeLine(i, time) {
  const row = i / NUM_LINES;
  const lineSpacing = H / (NUM_LINES + 10);
  const baseY = H * 0.08 + i * lineSpacing;
  const rowCenter = 0.45;
  const rowDist = Math.abs(row - rowCenter);

  const spikeRowEnv = Math.exp(-rowDist * rowDist / (2 * 0.05 * 0.05));
  const terrainEnv = Math.exp(-rowDist * rowDist / (2 * 0.15 * 0.15));
  const maxTerrain = H * 0.12 * terrainEnv;
  const maxSpike = H * 0.38 * spikeRowEnv;
  const bumpEnv = Math.exp(-rowDist * rowDist / (2 * 0.1 * 0.1));
  const alpha = 0.3 + 0.7 * Math.max(spikeRowEnv, terrainEnv * 0.5);

  const xs = new Float32Array(POINTS + 1);
  const ys = new Float32Array(POINTS + 1);

  for (let j = 0; j <= POINTS; j++) {
    const t = j / POINTS;
    const cx = (t - 0.5) * 2;

    const n = (fbm(t * 3 + time * 0.12, row * 3 + time * 0.06, 5) + 1) * 0.5;
    const terrain = n * maxTerrain;

    const sw = 0.025 + 0.005 * Math.sin(time * 0.5);
    const spike = Math.exp(-cx * cx / (2 * sw * sw));
    const spikeH = spike * maxSpike * (1 + 0.15 * Math.sin(time * 0.7));

    const p2 = Math.exp(-(cx - 0.35) * (cx - 0.35) / 0.015) * H * 0.06 * bumpEnv;
    const p3 = Math.exp(-(cx + 0.4) * (cx + 0.4) / 0.02) * H * 0.05 * bumpEnv;

    xs[j] = t * W;
    ys[j] = baseY - (terrain + spikeH + p2 + p3);
  }

  return { xs, ys, baseY, lineSpacing, alpha };
}

function draw() {
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Draw back to front (i=0 is top/back)
  for (let i = 0; i < NUM_LINES; i++) {
    const { xs, ys, baseY, lineSpacing, alpha } = computeLine(i, time);
    const fillBottom = baseY + lineSpacing;

    // 1. Draw black fill (occlusion) — triangle strip: line point, bottom point, ...
    const fillVerts = new Float32Array((POINTS + 1) * 4);
    const fillAlphas = new Float32Array((POINTS + 1) * 2);
    for (let j = 0; j <= POINTS; j++) {
      fillVerts[j * 4] = xs[j];
      fillVerts[j * 4 + 1] = ys[j];
      fillVerts[j * 4 + 2] = xs[j];
      fillVerts[j * 4 + 3] = fillBottom;
      fillAlphas[j * 2] = 1;
      fillAlphas[j * 2 + 1] = 1;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, fillVerts, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuf);
    gl.bufferData(gl.ARRAY_BUFFER, fillAlphas, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);

    gl.uniform4f(uColor, 0, 0, 0, 1);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, (POINTS + 1) * 2);

    // 2. Draw white line on top
    const lineVerts = new Float32Array((POINTS + 1) * 2);
    const lineAlphas = new Float32Array(POINTS + 1);
    for (let j = 0; j <= POINTS; j++) {
      lineVerts[j * 2] = xs[j];
      lineVerts[j * 2 + 1] = ys[j];
      lineAlphas[j] = alpha;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, lineVerts, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuf);
    gl.bufferData(gl.ARRAY_BUFFER, lineAlphas, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);

    gl.uniform4f(uColor, 1, 1, 1, 1);
    gl.drawArrays(gl.LINE_STRIP, 0, POINTS + 1);
  }

  time += 0.008;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
