<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Waveform Terrain — WebGL</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: -apple-system, sans-serif; }
  canvas { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

  #controls {
    position: fixed; top: 0; right: 0;
    width: 280px; max-height: 100vh; overflow-y: auto;
    background: rgba(0,0,0,0.85); border-left: 1px solid #333;
    padding: 16px; color: #ccc; font-size: 12px;
    transform: translateX(100%); transition: transform 0.3s;
    z-index: 10;
  }
  #controls.open { transform: translateX(0); }

  #toggle {
    position: fixed; top: 12px; right: 12px;
    background: rgba(255,255,255,0.1); border: 1px solid #555;
    color: #fff; padding: 6px 12px; cursor: pointer; font-size: 12px;
    border-radius: 4px; z-index: 11;
    transition: background 0.2s;
  }
  #toggle:hover { background: rgba(255,255,255,0.2); }

  .group { margin-bottom: 14px; }
  .group-title { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
  .param { margin-bottom: 8px; }
  .param label { display: flex; justify-content: space-between; margin-bottom: 2px; }
  .param label span.val { color: #fff; font-variant-numeric: tabular-nums; }
  .param input[type=range] {
    width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
    background: #333; border-radius: 2px; outline: none;
  }
  .param input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    background: #fff; border-radius: 50%; cursor: pointer;
  }
  .param input[type=checkbox] { margin-right: 6px; }

  #reset {
    width: 100%; padding: 6px; margin-top: 8px;
    background: #333; border: 1px solid #555; color: #ccc;
    cursor: pointer; border-radius: 4px; font-size: 11px;
  }
  #reset:hover { background: #444; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="toggle">⚙ Params</button>

<div id="controls">
  <div class="group">
    <div class="group-title">Structure</div>
    <div class="param">
      <label>Lines <span class="val" id="v_lines">180</span></label>
      <input type="range" id="p_lines" min="30" max="400" value="180" step="1">
    </div>
    <div class="param">
      <label>Points per line <span class="val" id="v_points">600</span></label>
      <input type="range" id="p_points" min="50" max="1000" value="600" step="10">
    </div>
  </div>

  <div class="group">
    <div class="group-title">Spike</div>
    <div class="param">
      <label>Spike height <span class="val" id="v_spikeHeight">0.38</span></label>
      <input type="range" id="p_spikeHeight" min="0" max="0.8" value="0.38" step="0.01">
    </div>
    <div class="param">
      <label>Spike width (σ) <span class="val" id="v_spikeWidth">0.025</span></label>
      <input type="range" id="p_spikeWidth" min="0.005" max="0.15" value="0.025" step="0.001">
    </div>
    <div class="param">
      <label>Spike row spread <span class="val" id="v_spikeRowSpread">0.05</span></label>
      <input type="range" id="p_spikeRowSpread" min="0.01" max="0.2" value="0.05" step="0.005">
    </div>
    <div class="param">
      <label>Spike X position <span class="val" id="v_spikeX">0.5</span></label>
      <input type="range" id="p_spikeX" min="0.1" max="0.9" value="0.5" step="0.01">
    </div>
  </div>

  <div class="group">
    <div class="group-title">Vertical Position</div>
    <div class="param">
      <label>Center row <span class="val" id="v_rowCenter">0.45</span></label>
      <input type="range" id="p_rowCenter" min="0.1" max="0.9" value="0.45" step="0.01">
    </div>
    <div class="param">
      <label>Top margin <span class="val" id="v_topMargin">0.08</span></label>
      <input type="range" id="p_topMargin" min="0" max="0.4" value="0.08" step="0.01">
    </div>
  </div>

  <div class="group">
    <div class="group-title">Terrain</div>
    <div class="param">
      <label>Terrain height <span class="val" id="v_terrainHeight">0.12</span></label>
      <input type="range" id="p_terrainHeight" min="0" max="0.4" value="0.12" step="0.01">
    </div>
    <div class="param">
      <label>Terrain spread <span class="val" id="v_terrainSpread">0.15</span></label>
      <input type="range" id="p_terrainSpread" min="0.02" max="0.5" value="0.15" step="0.01">
    </div>
    <div class="param">
      <label>Noise frequency <span class="val" id="v_noiseFreq">3</span></label>
      <input type="range" id="p_noiseFreq" min="0.5" max="10" value="3" step="0.1">
    </div>
    <div class="param">
      <label>Octaves <span class="val" id="v_octaves">5</span></label>
      <input type="range" id="p_octaves" min="1" max="8" value="5" step="1">
    </div>
  </div>

  <div class="group">
    <div class="group-title">Secondary Peaks</div>
    <div class="param">
      <label>Bump height <span class="val" id="v_bumpHeight">0.06</span></label>
      <input type="range" id="p_bumpHeight" min="0" max="0.2" value="0.06" step="0.005">
    </div>
    <div class="param">
      <label>Bump spread <span class="val" id="v_bumpSpread">0.1</span></label>
      <input type="range" id="p_bumpSpread" min="0.02" max="0.3" value="0.1" step="0.01">
    </div>
  </div>

  <div class="group">
    <div class="group-title">Animation</div>
    <div class="param">
      <label>Speed <span class="val" id="v_speed">0.008</span></label>
      <input type="range" id="p_speed" min="0" max="0.05" value="0.008" step="0.001">
    </div>
    <div class="param">
      <label><input type="checkbox" id="p_animate" checked> Animate</label>
    </div>
  </div>

  <button id="reset">Reset Defaults</button>
</div>

<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:2em">WebGL not supported</p>'; throw ''; }

const ASPECT = 16 / 9;
const RENDER_W = 1920, RENDER_H = Math.round(RENDER_W / ASPECT);

function resize() {
  canvas.width = RENDER_W; canvas.height = RENDER_H;
  gl.viewport(0, 0, RENDER_W, RENDER_H);
  const vw = window.innerWidth, vh = window.innerHeight;
  const scale = Math.max(vw / RENDER_W, vh / RENDER_H);
  canvas.style.width = (RENDER_W * scale) + 'px';
  canvas.style.height = (RENDER_H * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();

const vsrc = `
attribute vec2 aPos;
attribute float aAlpha;
varying float vAlpha;
void main() {
  vec2 clip = (aPos / vec2(${RENDER_W}.0, ${RENDER_H}.0)) * 2.0 - 1.0;
  clip.y = -clip.y;
  gl_Position = vec4(clip, 0.0, 1.0);
  vAlpha = aAlpha;
}`;

const fsrc = `
precision mediump float;
varying float vAlpha;
uniform vec4 uColor;
void main() {
  gl_FragColor = vec4(uColor.rgb, uColor.a * vAlpha);
}`;

function makeShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, makeShader(vsrc, gl.VERTEX_SHADER));
gl.attachShader(prog, makeShader(fsrc, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, 'aPos');
const aAlpha = gl.getAttribLocation(prog, 'aAlpha');
const uColor = gl.getUniformLocation(prog, 'uColor');

const posBuf = gl.createBuffer();
const alphaBuf = gl.createBuffer();

gl.enableVertexAttribArray(aPos);
gl.enableVertexAttribArray(aAlpha);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

// Noise
const perm = new Uint8Array(512);
const grad = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
(function() {
  const p = new Uint8Array(256);
  for (let i = 0; i < 256; i++) p[i] = i;
  for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
  for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
})();

function noise2d(x, y) {
  const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
  const xf = x - Math.floor(x), yf = y - Math.floor(y);
  const u = xf * xf * (3 - 2 * xf), v = yf * yf * (3 - 2 * yf);
  const aa = perm[perm[X] + Y], ab = perm[perm[X] + Y + 1];
  const ba = perm[perm[X + 1] + Y], bb = perm[perm[X + 1] + Y + 1];
  const dot = (g, dx, dy) => grad[g & 7][0] * dx + grad[g & 7][1] * dy;
  return (dot(aa,xf,yf)*(1-u)+dot(ba,xf-1,yf)*u)*(1-v) + (dot(ab,xf,yf-1)*(1-u)+dot(bb,xf-1,yf-1)*u)*v;
}

function fbm(x, y, oct) {
  let val = 0, amp = 1, freq = 1, max = 0;
  for (let i = 0; i < oct; i++) { val += noise2d(x*freq, y*freq)*amp; max += amp; amp *= 0.5; freq *= 2; }
  return val / max;
}

const W = RENDER_W, H = RENDER_H;

// Params
const P = {
  lines: 180, points: 600,
  spikeHeight: 0.38, spikeWidth: 0.025, spikeRowSpread: 0.05, spikeX: 0.5,
  rowCenter: 0.45, topMargin: 0.08,
  terrainHeight: 0.12, terrainSpread: 0.15, noiseFreq: 3, octaves: 5,
  bumpHeight: 0.06, bumpSpread: 0.1,
  speed: 0.008, animate: true
};
const DEFAULTS = { ...P };

// Wire controls
const ids = Object.keys(P).filter(k => k !== 'animate');
ids.forEach(k => {
  const el = document.getElementById('p_' + k);
  const vEl = document.getElementById('v_' + k);
  if (!el) return;
  el.addEventListener('input', () => { P[k] = parseFloat(el.value); vEl.textContent = el.value; });
});
document.getElementById('p_animate').addEventListener('change', e => { P.animate = e.target.checked; });
document.getElementById('toggle').addEventListener('click', () => {
  document.getElementById('controls').classList.toggle('open');
});
document.getElementById('reset').addEventListener('click', () => {
  Object.assign(P, DEFAULTS);
  ids.forEach(k => {
    const el = document.getElementById('p_' + k);
    const vEl = document.getElementById('v_' + k);
    if (el) { el.value = P[k]; vEl.textContent = P[k]; }
  });
  document.getElementById('p_animate').checked = true;
});

let time = 0;

function computeLine(i, time) {
  const { lines, points, spikeHeight, spikeWidth, spikeRowSpread, spikeX,
          rowCenter, topMargin, terrainHeight, terrainSpread, noiseFreq, octaves,
          bumpHeight, bumpSpread } = P;

  const row = i / lines;
  const lineSpacing = H / (lines + 10);
  const baseY = H * topMargin + i * lineSpacing;
  const rowDist = Math.abs(row - rowCenter);

  const spikeRowEnv = Math.exp(-rowDist * rowDist / (2 * spikeRowSpread * spikeRowSpread));
  const terrainEnv = Math.exp(-rowDist * rowDist / (2 * terrainSpread * terrainSpread));
  const maxTerrain = H * terrainHeight * terrainEnv;
  const maxSpike = H * spikeHeight * spikeRowEnv;
  const bumpEnv = Math.exp(-rowDist * rowDist / (2 * bumpSpread * bumpSpread));
  const alpha = 0.3 + 0.7 * Math.max(spikeRowEnv, terrainEnv * 0.5);

  const xs = new Float32Array(points + 1);
  const ys = new Float32Array(points + 1);

  for (let j = 0; j <= points; j++) {
    const t = j / points;
    const cx = (t - spikeX) * 2;

    const n = (fbm(t * noiseFreq + time * 0.12, row * 3 + time * 0.06, octaves) + 1) * 0.5;
    const terrain = n * maxTerrain;

    const sw = spikeWidth + 0.005 * Math.sin(time * 0.5);
    const spike = Math.exp(-cx * cx / (2 * sw * sw));
    const spikeH = spike * maxSpike * (1 + 0.15 * Math.sin(time * 0.7));

    const p2 = Math.exp(-(cx - 0.35) * (cx - 0.35) / 0.015) * H * bumpHeight * bumpEnv;
    const p3 = Math.exp(-(cx + 0.4) * (cx + 0.4) / 0.02) * H * (bumpHeight * 0.83) * bumpEnv;

    xs[j] = t * W;
    ys[j] = baseY - (terrain + spikeH + p2 + p3);
  }

  return { xs, ys, baseY, lineSpacing, alpha, points };
}

function draw() {
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  const { lines, points } = P;

  for (let i = 0; i < lines; i++) {
    const line = computeLine(i, time);
    const fillBottom = line.baseY + line.lineSpacing;
    const pts = line.points;

    // Black fill (occlusion)
    const fillVerts = new Float32Array((pts + 1) * 4);
    const fillAlphas = new Float32Array((pts + 1) * 2);
    for (let j = 0; j <= pts; j++) {
      fillVerts[j * 4] = line.xs[j];
      fillVerts[j * 4 + 1] = line.ys[j];
      fillVerts[j * 4 + 2] = line.xs[j];
      fillVerts[j * 4 + 3] = fillBottom;
      fillAlphas[j * 2] = 1;
      fillAlphas[j * 2 + 1] = 1;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, fillVerts, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuf);
    gl.bufferData(gl.ARRAY_BUFFER, fillAlphas, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);

    gl.uniform4f(uColor, 0, 0, 0, 1);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, (pts + 1) * 2);

    // White line
    const lineVerts = new Float32Array((pts + 1) * 2);
    const lineAlphas = new Float32Array(pts + 1);
    for (let j = 0; j <= pts; j++) {
      lineVerts[j * 2] = line.xs[j];
      lineVerts[j * 2 + 1] = line.ys[j];
      lineAlphas[j] = line.alpha;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, lineVerts, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuf);
    gl.bufferData(gl.ARRAY_BUFFER, lineAlphas, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);

    gl.uniform4f(uColor, 1, 1, 1, 1);
    gl.drawArrays(gl.LINE_STRIP, 0, pts + 1);
  }

  if (P.animate) time += P.speed;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
